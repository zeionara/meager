#include "../Setting.h"
#include "../Random.h"
#include "../Reader.h"
#include "../Corrupt.h"
#include "../main.h"
#include "../triple/list/main.h"
#include "main.h"

#include "none/main.h"
#include "none/reader.h"

#include "symmetric/reader.h"
#include "symmetric/main.h"

#include "../samplers/LocalSamplingState.h"

unordered_map<Pattern, PatternDescription> patternDescriptions; //  = {
    // {
    //     nonePatternName,
    //     PatternDescription(none, 1, noneTriplePatternInstances)
    // }// ,
    // {
    //     symmetricPatternName,
    //     PatternDescription(symmetric, 2, symmetricTriplePatternInstances)
    // }
// };

void* getPatternBatch(void* con) {
	LocalSamplingState* localState = (LocalSamplingState *)(con);
	GlobalSamplingState* state = localState->globalState;

	INT threadIndex = localState->id;
    Triple* triples = state->triples;
    REAL* labels = state->labels;
	INT batchSize = state->batchSize;
	INT entityNegativeRate = state->entityNegativeRate;
	INT relationNegativeRate = state->relationNegativeRate;
	INT headBatchFlag = state->headBatchFlag;
    // std::vector<PatternInstance>** patternInstanceSets = para -> patternInstanceSets;
    vector<PatternInstance>* patternInstances = state->patternInstances;
    INT nObservedTriplesPerPatternInstance = state->nObservedTriplesPerPatternInstance;
	REAL headCorruptionThreshold = state->headCorruptionThreshold;

	INT first_triple_index, last_triple_index;

    bool crossSamplingFlag = false;
    bool bernFlag = false;

	if (batchSize % workThreads == 0) {
		first_triple_index = threadIndex * (batchSize / workThreads);
		last_triple_index = (threadIndex + 1) * (batchSize / workThreads);
	} else {
		first_triple_index = threadIndex * (batchSize / workThreads + 1); // Last (incomplete) batch is distributed over all complete batches
		last_triple_index = (threadIndex + 1) * (batchSize / workThreads + 1);
		if (last_triple_index > batchSize) last_triple_index = batchSize;  // The last batch contains fewer elements
	}

    INT patternComponentOffset = batchSize * (1 + entityNegativeRate + relationNegativeRate);

	for (INT batchWiseTripleIndex = first_triple_index; batchWiseTripleIndex < last_triple_index; batchWiseTripleIndex++) {
        // cout << "foo" << (*(patternInstanceSets[nObservedTriplesPerPatternInstance])).size() << endl;
		INT sampled_triple_index = rand_max(threadIndex, (*patternInstances).size());
        // cout << "Sampled triple index = " << sampled_triple_index << endl;
        PatternInstance sampledPatternInstance = (*patternInstances)[sampled_triple_index];
        INT patternComponentIndex = 0;

        for (Triple sampledTriple: sampledPatternInstance.triples) {
            triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex] = sampledTriple;
            labels[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex] = 1;
            // INT last = batchSize;
            // Sample negative triples
            for (INT negativeTripleOffset = 1; negativeTripleOffset <= entityNegativeRate; negativeTripleOffset++) {
                if (!crossSamplingFlag){
                    if (bernFlag) // flag for considering a portion of triples with unique head/tail for those of which there is a given relationship
                        headCorruptionThreshold = 1000 * trainList->relationScore->head[sampledTriple.r] / (
                            trainList->relationScore->tail[sampledTriple.r] + trainList->relationScore->head[sampledTriple.r]
                        );
                    if (randd(threadIndex) % 1000 < headCorruptionThreshold) { // Corrupt TAIL by generating a random number
                        // cout << "corrupting tail" << endl;
                        triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = Triple(
                            sampledTriple.h, sampledTriple.r, corrupt_head(threadIndex, sampledTriple.h, sampledTriple.r)
                        );
                    } else { // Corrupt HEAD
                        triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = Triple(
                            corrupt_tail(threadIndex, sampledTriple.t, sampledTriple.r),  sampledTriple.r, sampledTriple.t
                        );
                    }
                    labels[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = -1;
                    // last += batchSize; // There will be <batchSize> triples generated by other threads which must be skipped
                } else  {
                    if(headBatchFlag){ // Corrupt HEAD by using provided flag which specifies which part of triple must be corrupted
                        triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = Triple(
                            corrupt_tail(threadIndex, sampledTriple.t, sampledTriple.r),  sampledTriple.r, sampledTriple.t
                        );
                    } else { // Corrupt TAIL
                        triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = Triple(
                            sampledTriple.h, sampledTriple.r, corrupt_head(threadIndex, sampledTriple.h, sampledTriple.r)
                        );
                    }
                    labels[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize] = -1;
                    // last += batchSize;
                }
            } // end loop for each negative triple with corrupted entity
            // Corrupt relations
            for (INT negativeTripleOffset = 1; negativeTripleOffset <= relationNegativeRate; negativeTripleOffset++) {
                triples[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + (entityNegativeRate + negativeTripleOffset) * batchSize] = Triple(
                    sampledTriple.h,  corrupt_rel(threadIndex, sampledTriple.h, sampledTriple.t), sampledTriple.t
                );
                labels[patternComponentOffset * patternComponentIndex + batchWiseTripleIndex + (entityNegativeRate + negativeTripleOffset) * batchSize] = -1;
                // last += batchSize;
            }
            patternComponentIndex += 1;
        }

        INT observedTripleIndexCounter = 0; // For tracking observed triples in their duplicating locations
        for (INT observedTripleIndex: sampledPatternInstance.observedTripleIndices) {
            if (observedTripleIndexCounter >= nObservedTriplesPerPatternInstance) {
                break;
            }

            triples[patternComponentOffset * (patternComponentIndex + observedTripleIndexCounter) + batchWiseTripleIndex] =
                triples[patternComponentOffset * observedTripleIndex + batchWiseTripleIndex];
            labels[patternComponentOffset * (patternComponentOffset + observedTripleIndexCounter) + batchWiseTripleIndex] = 1;
            // labels[patternComponentOffset * observedTripleIndex + batchWiseTripleIndex];

            // INT last = batchSize;

            for (INT negativeTripleOffset = 1; negativeTripleOffset <= entityNegativeRate + relationNegativeRate; negativeTripleOffset++) {
                triples[patternComponentOffset * (patternComponentIndex + observedTripleIndexCounter) + batchWiseTripleIndex + negativeTripleOffset * batchSize] =
                    triples[patternComponentOffset * observedTripleIndex + batchWiseTripleIndex + negativeTripleOffset * batchSize];
                labels[patternComponentOffset * (patternComponentIndex + observedTripleIndexCounter) + batchWiseTripleIndex + negativeTripleOffset * batchSize] = -1;
                // last += batchSize;
            }

            observedTripleIndexCounter++;
        }
	} // end loop for each positive triple in the batch which should be processed by the thread
	pthread_exit(NULL);
}

Pattern decodePatternName(string name) {
    if (name == "none" || name == "nil") {
        return none;
    }
    if (name == "inverse") {
        return inverse;
    }
    if (name == "symmetric") {
        return symmetric;
    }

    cout << "Pattern name " << name << " is unknown" << endl;
    throw "Unknown triple pattern provided";
}

